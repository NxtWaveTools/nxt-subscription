// ============================================================================
// Finance Subscription Actions
// Server actions for FINANCE role to manage subscriptions
// ============================================================================

'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import { getCurrentUser, hasAnyRole } from '@/lib/auth/user'
import { subscriptionSchemas } from '@/lib/validation/schemas'
import {
  SUBSCRIPTION_STATUS,
  FINANCE_ROUTES,
} from '@/lib/constants'
import { createAuditLog, AUDIT_ACTIONS, AUDIT_ENTITY_TYPES } from '@/lib/utils/audit-log'
import type { Subscription, SubscriptionInsert, SubscriptionUpdate } from '@/lib/types'

// ============================================================================
// Types
// ============================================================================

type ActionResponse<T = unknown> = {
  success: boolean
  error?: string
  data?: T
}

// ============================================================================
// Permission Helper
// ============================================================================

async function requireFinance() {
  const user = await getCurrentUser()
  if (!user) {
    throw new Error('Authentication required')
  }
  if (!hasAnyRole(user, ['FINANCE'])) {
    throw new Error('Only FINANCE can perform this action')
  }
  return user
}

// ============================================================================
// Subscription CRUD Operations
// ============================================================================

/**
 * Create a new subscription
 */
export async function createSubscription(
  data: SubscriptionInsert
): Promise<ActionResponse<Subscription>> {
  try {
    const currentUser = await requireFinance()
    const validated = subscriptionSchemas.create.parse(data)

    const supabase = await createClient()

    // Verify location exists if provided
    if (validated.location_id) {
      const { data: locationExists } = await supabase
        .from('locations')
        .select('id')
        .eq('id', validated.location_id)
        .single()

      if (!locationExists) {
        return {
          success: false,
          error: 'Invalid location',
        }
      }
    }

    const { data: subscription, error } = await supabase
      .from('subscriptions')
      .insert({
        request_type: validated.request_type,
        tool_name: validated.tool_name,
        vendor_name: validated.vendor_name,
        product_id: validated.product_id || null,
        department_id: validated.department_id,
        location_id: validated.location_id || null,
        amount: validated.amount,
        equivalent_inr_amount: validated.equivalent_inr_amount || null,
        currency: validated.currency,
        billing_frequency: validated.billing_frequency,
        start_date: validated.start_date.toISOString().split('T')[0],
        end_date: validated.end_date ? validated.end_date.toISOString().split('T')[0] : null,
        login_url: validated.login_url || null,
        subscription_email: validated.subscription_email || null,
        poc_email: validated.poc_email || null,
        mandate_id: validated.mandate_id || null,
        budget_period: validated.budget_period || null,
        payment_utr: validated.payment_utr || null,
        requester_remarks: validated.requester_remarks || null,
        // subscription_id is auto-generated by database trigger
        status: SUBSCRIPTION_STATUS.PENDING,
        payment_status: validated.payment_status || 'IN_PROGRESS',
        accounting_status: validated.accounting_status || 'PENDING',
        created_by: currentUser.id,
      })
      .select()
      .single()

    if (error) {
      console.error('Create subscription error:', error)
      return {
        success: false,
        error: 'Failed to create subscription',
      }
    }

    revalidatePath(FINANCE_ROUTES.SUBSCRIPTIONS)
    revalidatePath(FINANCE_ROUTES.DASHBOARD)

    // Audit log
    createAuditLog({
      userId: currentUser.id,
      action: AUDIT_ACTIONS.SUBSCRIPTION_CREATE,
      entityType: AUDIT_ENTITY_TYPES.SUBSCRIPTION,
      entityId: subscription.id,
      changes: { tool_name: validated.tool_name },
    }).catch(console.error)

    return {
      success: true,
      data: subscription as Subscription,
    }
  } catch (error) {
    console.error('Create subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Update a subscription
 */
export async function updateSubscription(
  subscriptionId: string,
  data: SubscriptionUpdate
): Promise<ActionResponse<Subscription>> {
  try {
    const currentUser = await requireFinance()
    subscriptionSchemas.subscriptionId.parse(subscriptionId)
    const validated = subscriptionSchemas.update.parse(data)

    const supabase = await createClient()

    // Check if subscription exists and user has permission
    const { data: existing, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status, created_by, version')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !existing) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Only allow editing own subscriptions or pending ones
    if (existing.created_by !== currentUser.id && existing.status !== SUBSCRIPTION_STATUS.PENDING) {
      return {
        success: false,
        error: 'Cannot edit this subscription',
      }
    }

    // Build update object with proper date handling
    // Include version increment for optimistic locking
    const updateData: Record<string, unknown> = {
      version: existing.version + 1,
    }
    
    if (validated.request_type !== undefined) updateData.request_type = validated.request_type
    if (validated.tool_name !== undefined) updateData.tool_name = validated.tool_name
    if (validated.vendor_name !== undefined) updateData.vendor_name = validated.vendor_name
    if (validated.product_id !== undefined) updateData.product_id = validated.product_id
    if (validated.department_id !== undefined) updateData.department_id = validated.department_id
    if (validated.location_id !== undefined) updateData.location_id = validated.location_id
    if (validated.amount !== undefined) updateData.amount = validated.amount
    if (validated.equivalent_inr_amount !== undefined) updateData.equivalent_inr_amount = validated.equivalent_inr_amount
    if (validated.currency !== undefined) updateData.currency = validated.currency
    if (validated.billing_frequency !== undefined) updateData.billing_frequency = validated.billing_frequency
    if (validated.start_date !== undefined) {
      updateData.start_date = validated.start_date instanceof Date 
        ? validated.start_date.toISOString().split('T')[0] 
        : validated.start_date
    }
    if (validated.end_date !== undefined) {
      updateData.end_date = validated.end_date instanceof Date 
        ? validated.end_date.toISOString().split('T')[0] 
        : validated.end_date
    }
    if (validated.login_url !== undefined) updateData.login_url = validated.login_url
    if (validated.subscription_email !== undefined) updateData.subscription_email = validated.subscription_email
    if (validated.poc_email !== undefined) updateData.poc_email = validated.poc_email
    if (validated.mandate_id !== undefined) updateData.mandate_id = validated.mandate_id
    if (validated.budget_period !== undefined) updateData.budget_period = validated.budget_period
    if (validated.payment_utr !== undefined) updateData.payment_utr = validated.payment_utr
    if (validated.requester_remarks !== undefined) updateData.requester_remarks = validated.requester_remarks
    if (validated.payment_status !== undefined) updateData.payment_status = validated.payment_status
    if (validated.accounting_status !== undefined) updateData.accounting_status = validated.accounting_status

    const { data: updated, error: updateError } = await supabase
      .from('subscriptions')
      .update(updateData)
      .eq('id', subscriptionId)
      .eq('version', existing.version) // Optimistic locking: only update if version matches
      .select()
      .single()

    if (updateError) {
      // Check for version conflict (no rows updated)
      if (updateError.code === 'PGRST116') {
        return {
          success: false,
          error: 'This subscription was modified by another user. Please refresh and try again.',
        }
      }
      console.error('Update subscription error:', updateError)
      return {
        success: false,
        error: 'Failed to update subscription',
      }
    }

    // Handle case where no rows were updated (version mismatch)
    if (!updated) {
      return {
        success: false,
        error: 'This subscription was modified by another user. Please refresh and try again.',
      }
    }

    revalidatePath(FINANCE_ROUTES.SUBSCRIPTIONS)
    revalidatePath(`${FINANCE_ROUTES.SUBSCRIPTIONS}/${subscriptionId}`)

    // Audit log
    createAuditLog({
      userId: currentUser.id,
      action: AUDIT_ACTIONS.SUBSCRIPTION_UPDATE,
      entityType: AUDIT_ENTITY_TYPES.SUBSCRIPTION,
      entityId: subscriptionId,
      changes: validated,
    }).catch(console.error)

    return {
      success: true,
      data: updated as Subscription,
    }
  } catch (error) {
    console.error('Update subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Cancel a subscription
 */
export async function cancelSubscription(
  subscriptionId: string
): Promise<ActionResponse<Subscription>> {
  try {
    const currentUser = await requireFinance()
    subscriptionSchemas.subscriptionId.parse(subscriptionId)

    const supabase = await createClient()

    // Check if subscription exists
    const { data: existing, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status, version')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !existing) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    if (existing.status !== SUBSCRIPTION_STATUS.ACTIVE) {
      return {
        success: false,
        error: 'Only active subscriptions can be cancelled',
      }
    }

    const { data: updated, error: updateError } = await supabase
      .from('subscriptions')
      .update({ 
        status: SUBSCRIPTION_STATUS.CANCELLED,
        version: existing.version + 1,
      })
      .eq('id', subscriptionId)
      .eq('version', existing.version) // Optimistic locking
      .select()
      .single()

    if (updateError) {
      if (updateError.code === 'PGRST116') {
        return {
          success: false,
          error: 'This subscription was modified by another user. Please refresh and try again.',
        }
      }
      console.error('Cancel subscription error:', updateError)
      return {
        success: false,
        error: 'Failed to cancel subscription',
      }
    }

    if (!updated) {
      return {
        success: false,
        error: 'This subscription was modified by another user. Please refresh and try again.',
      }
    }

    revalidatePath(FINANCE_ROUTES.SUBSCRIPTIONS)
    revalidatePath(`${FINANCE_ROUTES.SUBSCRIPTIONS}/${subscriptionId}`)

    // Audit log
    createAuditLog({
      userId: currentUser.id,
      action: AUDIT_ACTIONS.SUBSCRIPTION_CANCEL,
      entityType: AUDIT_ENTITY_TYPES.SUBSCRIPTION,
      entityId: subscriptionId,
      changes: { status: 'CANCELLED' },
    }).catch(console.error)

    return {
      success: true,
      data: updated as Subscription,
    }
  } catch (error) {
    console.error('Cancel subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Delete a subscription (only PENDING or REJECTED)
 */
export async function deleteSubscription(
  subscriptionId: string
): Promise<ActionResponse> {
  try {
    const currentUser = await requireFinance()
    subscriptionSchemas.subscriptionId.parse(subscriptionId)

    const supabase = await createClient()

    // Check if subscription exists
    const { data: existing, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status, tool_name')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !existing) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Only allow deleting PENDING or REJECTED subscriptions
    const allowedStatuses: string[] = [SUBSCRIPTION_STATUS.PENDING, SUBSCRIPTION_STATUS.REJECTED]
    if (!allowedStatuses.includes(existing.status)) {
      return {
        success: false,
        error: 'Only pending or rejected subscriptions can be deleted',
      }
    }

    const { error: deleteError } = await supabase
      .from('subscriptions')
      .delete()
      .eq('id', subscriptionId)

    if (deleteError) {
      console.error('Delete subscription error:', deleteError)
      return {
        success: false,
        error: 'Failed to delete subscription',
      }
    }

    revalidatePath(FINANCE_ROUTES.SUBSCRIPTIONS)

    // Audit log
    createAuditLog({
      userId: currentUser.id,
      action: AUDIT_ACTIONS.SUBSCRIPTION_DELETE,
      entityType: AUDIT_ENTITY_TYPES.SUBSCRIPTION,
      entityId: subscriptionId,
      changes: { tool_name: existing.tool_name },
    }).catch(console.error)

    return {
      success: true,
    }
  } catch (error) {
    console.error('Delete subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}
