// ============================================================================
// Subscription Server Actions
// Admin operations for subscription management with approval workflow
// ============================================================================

'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import { requireAdmin, getCurrentUser, hasAnyRole, hasRole } from '@/lib/auth/user'
import { subscriptionSchemas } from '@/lib/validation/schemas'
import {
  SUBSCRIPTION_STATUS,
  SUBSCRIPTION_ROUTES,
  APPROVAL_ACTIONS,
} from '@/lib/constants'
import { getSubscriptionStatus } from '@/lib/data-access/subscriptions'
import { 
  calculateFirstCycleDates, 
  calculateInvoiceDeadline,
  formatDateForDB 
} from '@/lib/utils/cycle-calculator'
import type { Subscription, SubscriptionInsert, SubscriptionUpdate } from '@/lib/types'

// ============================================================================
// Types
// ============================================================================

type ActionResponse<T = unknown> = {
  success: boolean
  error?: string
  data?: T
  warning?: string
}

// ============================================================================
// Permission Helpers
// ============================================================================

/**
 * Require FINANCE or ADMIN role for creating/editing subscriptions
 */
async function requireFinanceOrAdmin() {
  const user = await getCurrentUser()
  if (!user) {
    throw new Error('Authentication required')
  }
  if (!hasAnyRole(user, ['ADMIN', 'FINANCE'])) {
    throw new Error('Only FINANCE or ADMIN can create or edit subscriptions')
  }
  return user
}

/**
 * Require POC role for approving subscriptions
 */
async function requirePOCForDepartment(departmentId: string) {
  const user = await getCurrentUser()
  if (!user) {
    throw new Error('Authentication required')
  }

  // ADMIN can approve on behalf of POC
  if (hasRole(user, 'ADMIN')) {
    return user
  }

  if (!hasRole(user, 'POC')) {
    throw new Error('Only POC can approve or reject subscriptions')
  }

  // Check if POC has access to this department
  const supabase = await createClient()
  const { data: pocAccess } = await supabase
    .from('poc_department_access')
    .select('department_id')
    .eq('poc_id', user.id)
    .eq('department_id', departmentId)
    .maybeSingle()

  if (!pocAccess) {
    throw new Error('You are not the POC for this department')
  }

  return user
}

// ============================================================================
// Helper Functions
// ============================================================================

// NOTE: Notification functions removed - notifications feature not required

// ============================================================================
// Subscription CRUD Operations
// ============================================================================

/**
 * Create a new subscription (FINANCE creates for departments)
 */
export async function createSubscription(
  data: SubscriptionInsert
): Promise<ActionResponse<Subscription>> {
  try {
    const currentUser = await requireFinanceOrAdmin()

    // Validate input
    const validated = subscriptionSchemas.create.parse(data)

    const supabase = await createClient()

    // Verify department exists
    const { data: department, error: deptError } = await supabase
      .from('departments')
      .select('id, name')
      .eq('id', validated.department_id)
      .eq('is_active', true)
      .maybeSingle()

    if (deptError || !department) {
      return {
        success: false,
        error: 'Invalid or inactive department',
      }
    }

    // Create subscription with PENDING status
    const { data: subscription, error } = await supabase
      .from('subscriptions')
      .insert({
        request_type: validated.request_type,
        tool_name: validated.tool_name,
        vendor_name: validated.vendor_name,
        pr_id: validated.pr_id,
        department_id: validated.department_id,
        amount: validated.amount,
        equivalent_inr_amount: validated.equivalent_inr_amount || null,
        currency: validated.currency,
        billing_frequency: validated.billing_frequency,
        start_date: validated.start_date.toISOString().split('T')[0],
        end_date: validated.end_date.toISOString().split('T')[0],
        login_url: validated.login_url || null,
        subscription_email: validated.subscription_email || null,
        poc_email: validated.poc_email || null,
        mandate_id: validated.mandate_id || null,
        requester_remarks: validated.requester_remarks || null,
        subscription_id: '', // Will be auto-generated by database trigger
        status: SUBSCRIPTION_STATUS.PENDING,
        payment_status: 'PAID',
        created_by: currentUser.id,
        version: 1,
      })
      .select()
      .single()

    if (error) {
      console.error('Create subscription error:', error)
      return {
        success: false,
        error: 'Failed to create subscription',
      }
    }

    revalidatePath(SUBSCRIPTION_ROUTES.SUBSCRIPTIONS)
    revalidatePath(SUBSCRIPTION_ROUTES.APPROVALS)

    // Auto-create first payment cycle as PAID (first cycle is already paid when subscription starts)
    try {
      const { startDate, endDate } = calculateFirstCycleDates(
        subscription.start_date!,
        subscription.billing_frequency
      )
      
      const invoiceDeadline = calculateInvoiceDeadline(endDate)

      const { error: cycleError } = await supabase
        .from('subscription_payments')
        .insert({
          subscription_id: subscription.id,
          cycle_number: 1,
          cycle_start_date: formatDateForDB(startDate),
          cycle_end_date: formatDateForDB(endDate),
          invoice_deadline: formatDateForDB(invoiceDeadline),
          // First cycle is auto-approved and paid
          poc_approval_status: 'APPROVED',
          poc_approved_by: currentUser.id,
          poc_approved_at: new Date().toISOString(),
          cycle_status: 'PAID', // First cycle is already paid
          payment_status: 'PAID',
          accounting_status: 'PENDING',
        })

      if (cycleError) {
        console.error('Failed to create first payment cycle:', cycleError)
        // Don't fail the entire subscription creation, just log the error
        // The cycle can be created manually later
      }
    } catch (cycleCreationError) {
      console.error('Error creating first payment cycle:', cycleCreationError)
      // Continue - subscription is created successfully
    }

    return {
      success: true,
      data: subscription as Subscription,
    }
  } catch (error) {
    console.error('Create subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Update a subscription
 * If status is ACTIVE, it will be set back to PENDING for re-approval
 */
export async function updateSubscription(
  subscriptionId: string,
  updates: SubscriptionUpdate
): Promise<ActionResponse<Subscription>> {
  try {
    const currentUser = await requireFinanceOrAdmin()

    // Validate ID
    subscriptionSchemas.subscriptionId.parse(subscriptionId)

    // Validate updates
    const validated = subscriptionSchemas.update.parse(updates)

    const supabase = await createClient()

    // Get current subscription
    const { data: existing, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status, version, tool_name, department_id, created_by')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !existing) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Check if editing an ACTIVE subscription requires re-approval
    const requiresReApproval = existing.status === SUBSCRIPTION_STATUS.ACTIVE

    // Build update object
    const updateData: Record<string, unknown> = {
      ...validated,
      version: existing.version + 1,
    }

    // Set status back to PENDING if it was ACTIVE
    if (requiresReApproval) {
      updateData.status = SUBSCRIPTION_STATUS.PENDING
    }

    // Update subscription with optimistic concurrency control
    // Check version to prevent race conditions from concurrent updates
    const { data: subscription, error } = await supabase
      .from('subscriptions')
      .update(updateData)
      .eq('id', subscriptionId)
      .eq('version', existing.version) // Optimistic locking
      .select()
      .single()

    // If no rows updated, it means another update happened (version mismatch)
    if (!subscription && !error) {
      return {
        success: false,
        error: 'Subscription was modified by another user. Please refresh and try again.',
      }
    }

    if (error) {
      console.error('Update subscription error:', error)
      return {
        success: false,
        error: 'Failed to update subscription',
      }
    }

    revalidatePath(SUBSCRIPTION_ROUTES.SUBSCRIPTIONS)
    revalidatePath(`${SUBSCRIPTION_ROUTES.SUBSCRIPTIONS}/${subscriptionId}`)
    revalidatePath(SUBSCRIPTION_ROUTES.APPROVALS)

    return {
      success: true,
      data: subscription as Subscription,
      warning: requiresReApproval
        ? 'Subscription requires re-approval due to changes'
        : undefined,
    }
  } catch (error) {
    console.error('Update subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Approve a subscription (POC action)
 */
export async function approveSubscription(
  subscriptionId: string,
  comments?: string
): Promise<ActionResponse<Subscription>> {
  try {
    // Validate input
    subscriptionSchemas.subscriptionId.parse(subscriptionId)
    const validated = subscriptionSchemas.approve.parse({ comments })

    const supabase = await createClient()

    // Get subscription
    const { data: subscription, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status, department_id, tool_name, created_by')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !subscription) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Check POC permission
    const currentUser = await requirePOCForDepartment(subscription.department_id)

    // Verify subscription is PENDING
    if (subscription.status !== SUBSCRIPTION_STATUS.PENDING) {
      return {
        success: false,
        error: `Subscription cannot be approved. Current status: ${subscription.status}`,
      }
    }

    // Update subscription status to ACTIVE
    const { data: updated, error: updateError } = await supabase
      .from('subscriptions')
      .update({ status: SUBSCRIPTION_STATUS.ACTIVE })
      .eq('id', subscriptionId)
      .select()
      .single()

    if (updateError) {
      console.error('Approve subscription error:', updateError)
      return {
        success: false,
        error: 'Failed to approve subscription',
      }
    }

    // Record approval in history
    await supabase.from('subscription_approvals').insert({
      subscription_id: subscriptionId,
      approver_id: currentUser.id,
      action: APPROVAL_ACTIONS.APPROVED,
      comments: validated.comments || null,
    })

    revalidatePath(SUBSCRIPTION_ROUTES.SUBSCRIPTIONS)
    revalidatePath(`${SUBSCRIPTION_ROUTES.SUBSCRIPTIONS}/${subscriptionId}`)
    revalidatePath(SUBSCRIPTION_ROUTES.APPROVALS)

    return {
      success: true,
      data: updated as Subscription,
    }
  } catch (error) {
    console.error('Approve subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Reject a subscription (POC action)
 */
export async function rejectSubscription(
  subscriptionId: string,
  comments: string
): Promise<ActionResponse<Subscription>> {
  try {
    // Validate input
    subscriptionSchemas.subscriptionId.parse(subscriptionId)
    const validated = subscriptionSchemas.reject.parse({ comments })

    const supabase = await createClient()

    // Get subscription
    const { data: subscription, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status, department_id, tool_name, created_by')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !subscription) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Check POC permission
    const currentUser = await requirePOCForDepartment(subscription.department_id)

    // Verify subscription is PENDING
    if (subscription.status !== SUBSCRIPTION_STATUS.PENDING) {
      return {
        success: false,
        error: `Subscription cannot be rejected. Current status: ${subscription.status}`,
      }
    }

    // Update subscription status to REJECTED
    const { data: updated, error: updateError } = await supabase
      .from('subscriptions')
      .update({ status: SUBSCRIPTION_STATUS.REJECTED })
      .eq('id', subscriptionId)
      .select()
      .single()

    if (updateError) {
      console.error('Reject subscription error:', updateError)
      return {
        success: false,
        error: 'Failed to reject subscription',
      }
    }

    // Record rejection in history
    await supabase.from('subscription_approvals').insert({
      subscription_id: subscriptionId,
      approver_id: currentUser.id,
      action: APPROVAL_ACTIONS.REJECTED,
      comments: validated.comments,
    })

    revalidatePath(SUBSCRIPTION_ROUTES.SUBSCRIPTIONS)
    revalidatePath(`${SUBSCRIPTION_ROUTES.SUBSCRIPTIONS}/${subscriptionId}`)
    revalidatePath(SUBSCRIPTION_ROUTES.APPROVALS)

    return {
      success: true,
      data: updated as Subscription,
    }
  } catch (error) {
    console.error('Reject subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Cancel a subscription (ADMIN/FINANCE action)
 */
export async function cancelSubscription(
  subscriptionId: string
): Promise<ActionResponse<Subscription>> {
  try {
    const currentUser = await requireFinanceOrAdmin()

    // Validate input
    subscriptionSchemas.subscriptionId.parse(subscriptionId)

    const supabase = await createClient()

    // Get subscription
    const { data: subscription, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status, tool_name')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !subscription) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Cannot cancel if already cancelled
    if (subscription.status === SUBSCRIPTION_STATUS.CANCELLED) {
      return {
        success: false,
        error: 'Subscription is already cancelled',
      }
    }

    // Update subscription status to CANCELLED
    const { data: updated, error: updateError } = await supabase
      .from('subscriptions')
      .update({ status: SUBSCRIPTION_STATUS.CANCELLED })
      .eq('id', subscriptionId)
      .select()
      .single()

    if (updateError) {
      console.error('Cancel subscription error:', updateError)
      return {
        success: false,
        error: 'Failed to cancel subscription',
      }
    }

    revalidatePath(SUBSCRIPTION_ROUTES.SUBSCRIPTIONS)
    revalidatePath(`${SUBSCRIPTION_ROUTES.SUBSCRIPTIONS}/${subscriptionId}`)

    return {
      success: true,
      data: updated as Subscription,
    }
  } catch (error) {
    console.error('Cancel subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Update payment status (ADMIN/FINANCE action)
 */
export async function updatePaymentStatus(
  subscriptionId: string,
  paymentStatus: string
): Promise<ActionResponse<Subscription>> {
  try {
    const currentUser = await requireFinanceOrAdmin()

    // Validate input
    subscriptionSchemas.subscriptionId.parse(subscriptionId)
    const validated = subscriptionSchemas.updatePayment.parse({ payment_status: paymentStatus })

    const supabase = await createClient()

    // Check subscription exists
    const status = await getSubscriptionStatus(subscriptionId)
    if (!status.exists) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Update payment status
    const { data: subscription, error } = await supabase
      .from('subscriptions')
      .update({ payment_status: validated.payment_status })
      .eq('id', subscriptionId)
      .select()
      .single()

    if (error) {
      console.error('Update payment status error:', error)
      return {
        success: false,
        error: 'Failed to update payment status',
      }
    }

    revalidatePath(SUBSCRIPTION_ROUTES.SUBSCRIPTIONS)
    revalidatePath(`${SUBSCRIPTION_ROUTES.SUBSCRIPTIONS}/${subscriptionId}`)

    return {
      success: true,
      data: subscription as Subscription,
    }
  } catch (error) {
    console.error('Update payment status error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Delete a subscription (ADMIN only)
 */
export async function deleteSubscription(
  subscriptionId: string
): Promise<ActionResponse> {
  try {
    const currentUser = await requireAdmin()

    // Validate input
    subscriptionSchemas.subscriptionId.parse(subscriptionId)

    const supabase = await createClient()

    // Get subscription
    const { data: subscription, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, tool_name')
      .eq('id', subscriptionId)
      .single()

    if (fetchError || !subscription) {
      return {
        success: false,
        error: 'Subscription not found',
      }
    }

    // Delete subscription (files and approvals will be cascaded)
    const { error } = await supabase
      .from('subscriptions')
      .delete()
      .eq('id', subscriptionId)

    if (error) {
      console.error('Delete subscription error:', error)
      return {
        success: false,
        error: 'Failed to delete subscription',
      }
    }

    revalidatePath(SUBSCRIPTION_ROUTES.SUBSCRIPTIONS)

    return {
      success: true,
    }
  } catch (error) {
    console.error('Delete subscription error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

// ============================================================================
// Auto-Cancel Operations
// ============================================================================

interface AutoCancelResult {
  cancelled_count: number
  notification_count: number
  error_message: string | null
}

/**
 * Manually trigger auto-cancel of overdue invoice payment cycles
 * Admin-only operation
 */
export async function triggerAutoCancelOverdueInvoices(): Promise<ActionResponse<{
  cancelledCount: number
  notificationCount: number
  errorMessage?: string
}>> {
  try {
    const currentUser = await requireAdmin()
    const supabase = await createClient()

    // Call the database function to process overdue invoices
    // Using raw SQL since the function isn't in generated types yet
    const { data, error } = await supabase
      .rpc('auto_cancel_overdue_invoices' as never)
      .single<AutoCancelResult>()

    if (error) {
      console.error('Auto-cancel error:', error)
      return {
        success: false,
        error: 'Failed to process overdue invoices: ' + error.message,
      }
    }

    revalidatePath('/admin/subscriptions')
    revalidatePath('/finance')
    revalidatePath('/poc')
    revalidatePath('/hod')

    return {
      success: true,
      data: {
        cancelledCount: data?.cancelled_count || 0,
        notificationCount: data?.notification_count || 0,
        errorMessage: data?.error_message || undefined,
      },
    }
  } catch (error) {
    console.error('Trigger auto-cancel error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}

/**
 * Get count of overdue invoice payment cycles
 * Cycles that are APPROVED but invoice deadline has passed
 * Admin-only operation
 */
export async function getOverdueInvoiceCount(): Promise<ActionResponse<number>> {
  try {
    await requireAdmin()
    const supabase = await createClient()

    const today = new Date().toISOString().split('T')[0]

    const { count, error } = await supabase
      .from('subscription_payments')
      .select('*', { count: 'exact', head: true })
      .eq('cycle_status', 'APPROVED')
      .is('invoice_file_id', null)
      .lt('invoice_deadline', today)

    if (error) {
      console.error('Get overdue count error:', error)
      return {
        success: false,
        error: 'Failed to get overdue count',
      }
    }

    return {
      success: true,
      data: count || 0,
    }
  } catch (error) {
    console.error('Get overdue count error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'An error occurred',
    }
  }
}
